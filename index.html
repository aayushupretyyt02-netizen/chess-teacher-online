<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="An elite chess opening trainer to help you master your openings and improve your game.">

    <meta property="og:title" content="Elite Chess Trainer">
    <meta property="og:description" content="The definitive tool to master your chess openings.">
    <meta property="og:type" content="website">

    <title>Elite Chess Trainer</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* Reset and base styles */
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: #0D1117;
            color: #C9D1D9;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Aurora background effect */
        @keyframes aurora {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .aurora-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background:
                radial-gradient(ellipse at top, transparent 50%, rgba(29, 78, 216, 0.15)),
                radial-gradient(ellipse at bottom, transparent 50%, rgba(107, 33, 168, 0.15));
            animation: aurora 20s infinite linear;
            z-index: 0;
        }

        /* Main container */
        .main-container {
            position: relative;
            z-index: 1;
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1rem 0;
        }

        header h1 {
            font-size: clamp(2rem, 8vw, 3.5rem);
            font-weight: 700;
            color: white;
            margin: 0 0 0.5rem 0;
            line-height: 1.2;
        }

        header p {
            font-size: clamp(0.875rem, 3vw, 1.125rem);
            color: #94a3b8;
            margin: 0.25rem 0;
            line-height: 1.5;
        }

        /* Main grid layout */
        .main-grid {
            display: grid;
            gap: 2rem;
            width: 100%;
        }

        /* Command center */
        .command-center {
            background: rgba(13, 17, 23, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .command-center h2 {
            color: #f8fafc;
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #475569;
        }

        /* Form styling */
        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: #e2e8f0;
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }

        .form-select {
            width: 100%;
            background-color: #21262D;
            border: 1px solid #30363D;
            color: #C9D1D9;
            font-size: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            min-height: 48px;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.75rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
            transition: all 0.2s ease-in-out;
        }

        .form-select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(45, 128, 255, 0.6);
            border-color: #2F81F7;
            transform: translateY(-1px);
        }

        .form-select option {
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 0.5rem;
        }

        /* Button grid */
        .button-grid {
            display: grid;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        /* Button styles */
        .btn {
            background-color: #21262D;
            border: 1px solid #30363D;
            color: #C9D1D9;
            font-size: 1rem;
            font-weight: 500;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            min-height: 48px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            border: none;
        }

        .btn:hover {
            background-color: #30363D;
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(45, 128, 255, 0.6);
            border-color: #2F81F7;
        }

        /* Specific button styles */
        .start-btn {
            background: linear-gradient(135deg, #238636 0%, #2EA043 100%);
             border-color: #2EA043;
            font-weight: 600;
        }

        .start-btn:hover {
            background: linear-gradient(135deg, #2EA043 0%, #3FB950 100%);
            box-shadow: 0 10px 25px -5px rgba(46, 160, 67, 0.4);
        }

        .start-bot-btn {
            background: linear-gradient(135deg, #1a73e8 0%, #4285f4 100%);
            border-color: #1764cc;
            font-weight: 600;
        }

        .start-bot-btn:hover {
            background: linear-gradient(135deg, #4285f4 0%, #5a9cff 100%);
            box-shadow: 0 10px 25px -5px rgba(26, 115, 232, 0.4);
        }

        .undo-btn {
            background: linear-gradient(135deg, #d97706 0%, #f59e0b 100%);
            border-color: #b45309;
            font-weight: 600;
        }

        .undo-btn:hover {
            background: linear-gradient(135deg, #f59e0b 0%, #fbbf24 100%);
            box-shadow: 0 10px 25px -5px rgba(217, 119, 6, 0.4);
        }

        /* Status panel */
#status {
    background: rgba(30, 41, 59, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 0.75rem;
    padding: 1.5rem;
    text-align: center;
    box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
    margin-bottom: 1rem;
    /* --- UPDATED LINES TO FIX THE SHIFTING --- */
    height: 160px; /* Sets a fixed height */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center; /* Centers content horizontally */
    /* --- END OF UPDATED LINES --- */
}

        #status-opening {
            font-size: 1.25rem;
            font-weight: 600;
            color: white;
            margin: 0 0 0.5rem 0;
        }

        #status-move {
            font-size: 1rem;
            color: #cbd5e1;
            margin: 0;
            line-height: 1.5;
        }

        #evaluation-display {
            font-size: 1.1rem;
            font-weight: 500;
            margin-top: 8px;
            color: #c9d1d9;
            min-height: 24px;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
        }

        /* Board container */
        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            width: 100%;
        }

        #myBoard {
            touch-action: none;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            height: auto;
        }

        /* Tips section */
        .tips-section {
            background: rgba(30, 41, 59, 0.6);
            border-radius: 0.75rem;
            padding: 1rem;
            text-align: center;
            width: 100%;
        }

        .tips-section p {
            margin: 0.25rem 0;
            font-size: 0.875rem;
            color: #94a3b8;
            line-height: 1.4;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: 2rem;
            padding: 1rem;
            color: #64748b;
            font-size: 0.875rem;
        }

        /* Evaluation colors */
        .eval-white { color: #6ee7b7; }
        .eval-black { color: #ef4444; }
        .eval-even { color: #60a5fa; }

        /* Feedback colors */
        .feedback-blunder { color: #f87171; font-weight: bold; }
        .feedback-mistake { color: #facc15; font-weight: bold; }
        .feedback-inaccuracy { color: #fdba74; }
        .feedback-good { color: #a3e635; }
        .feedback-best { color: #34d399; font-weight: bold; }
        .feedback-book { color: #60a5fa; }

        /* Board highlights */
        /* --- START: UPDATED STYLES --- */
        /* This makes sure the squares can contain the dot correctly */
        .square-55d63 {
            position: relative;
        }
        
        .highlight-correct {
            box-shadow: 0 0 25px 8px rgba(34, 197, 94, 0.7);
        }

        .highlight-incorrect {
            box-shadow: 0 0 25px 8px rgba(239, 68, 68, 0.7);
        }

        .highlight-selected {
            background: rgba(45, 128, 255, 0.5) !important;
        }

        /* This is the new style for the dot using a pseudo-element */
        .highlight-legal-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35%;
            height: 35%;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.4);
            pointer-events: none; /* Allows clicks to go through to the square */
        }
        /* --- END: UPDATED STYLES --- */

        .highlight-check {
            background: radial-gradient(circle, rgba(239, 68, 68, 0.5) 80%, transparent 100%);
        }

        .highlight-checkmate-winner {
            background: radial-gradient(circle, rgba(34, 197, 94, 0.5) 80%, transparent 100%);
        }

        .highlight-checkmate-loser {
            background: radial-gradient(circle, rgba(239, 68, 68, 0.5) 80%, transparent 100%);
        }

        /* Arrow styling */
        .arrow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .arrow line {
            stroke: rgba(239, 68, 68, 0.8);
            stroke-width: 10;
            stroke-linecap: round;
        }

        .arrow polygon {
            fill: rgba(239, 68, 68, 0.8);
        }

        /* Make sure board container is set to relative positioning */
        #myBoard {
            position: relative;
        }

        /* Animations */
        @keyframes shake-and-fade {
            0% { transform: translate(0, 0) rotate(0deg); opacity: 1; }
            10% { transform: translate(-10px, -10px) rotate(-10deg); }
            20% { transform: translate(10px, 10px) rotate(10deg); }
            30% { transform: translate(-10px, 10px) rotate(0deg); }
            40% { transform: translate(10px, -10px) rotate(10deg); }
            50% { transform: translate(-10px, -10px) rotate(-10deg); }
            60% { transform: translate(10px, 10px) rotate(0deg); }
            70% { transform: translate(-10px, 10px) rotate(10deg); }
            80% { transform: translate(10px, -10px) rotate(-10deg); }
            90% { transform: translate(0, 0) rotate(0deg); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }

        .king-capture-animation {
            animation: shake-and-fade 1s ease-in-out forwards;
        }

        /* Mobile-first responsive design */
        @media (max-width: 767px) {
            .main-container {
                padding: 0.5rem;
            }

            .main-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .command-center {
                order: 2;
                padding: 1rem;
            }

            .board-section {
                order: 1;
            }

            .button-grid {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }

            .btn {
                min-height: 56px;
                font-size: 1.1rem;
                font-weight: 600;
            }

            .form-select {
                min-height: 52px;
                font-size: 1rem;
            }

            .form-group {
                margin-bottom: 1rem;
            }

            #status {
                padding: 1rem;
                margin-bottom: 1rem;
            }

            #status-opening {
                font-size: 1.125rem;
            }

            #status-move {
                font-size: 0.9375rem;
            }

            .tips-section {
                padding: 0.875rem;
            }

            .tips-section p {
                font-size: 0.8125rem;
            }

            header h1 {
                font-size: clamp(1.75rem, 10vw, 2.5rem);
            }

            header p {
                font-size: clamp(0.75rem, 4vw, 1rem);
            }
        }

        /* Tablet */
        @media (min-width: 768px) and (max-width: 1023px) {
            .main-container {
                padding: 1.5rem;
            }

            .main-grid {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }

            .button-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1rem;
            }

            .button-grid .btn:last-child {
                grid-column: 1 / -1;
            }

            .command-center {
                padding: 1.5rem;
            }
        }

        /* Desktop */
        @media (min-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr 1fr;
                gap: 2.5rem;
            }

            .command-center {
                padding: 2rem;
            }

            .button-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1rem;
            }

            .button-grid .btn:last-child {
                grid-column: 1 / -1;
            }

            #myBoard {
                max-width: 500px;
            }
        }

        /* Large desktop */
        @media (min-width: 1280px) {
            .main-container {
                max-width: 1400px;
                padding: 2rem;
            }

            .main-grid {
                gap: 3rem;
            }

            .button-grid {
                gap: 1.25rem;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .btn {
                min-height: 56px;
                font-size: 1.1rem;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            .form-select {
                min-height: 52px;
            }

            .form-group label {
                margin-bottom: 0.75rem;
            }

            .btn:active {
                transform: scale(0.98);
                transition: transform 0.1s ease;
            }
        }

        /* High contrast mode */
        @media (prefers-contrast: high) {
            .btn, .form-select, #status {
                border-width: 2px;
            }
        }

        /* Reduced motion */
        @media (prefers-reduced-motion: reduce) {
            .btn, .form-select, .aurora-background {
                transition: none;
                animation: none;
            }
        }

        /* Focus visible for accessibility */
        .btn:focus-visible,
        .form-select:focus-visible {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }

        /* Loading states */
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4 md:p-6">

    <div class="aurora-background"></div>
    <main class="main-container w-full max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-white tracking-wide">Chess Opening Trainer</h1>
            <p class="text-lg text-slate-400 mt-2">The definitive tool to master your openings.</p>
            <p class="text-sm text-slate-500 mt-1">Click pieces to select, then click destination. Or drag and drop.</p>
        </header>

        <div class="main-grid">
            <section class="command-center" aria-labelledby="training-setup-heading">
                <h2 id="training-setup-heading" class="text-2xl font-bold mb-5 border-b border-slate-700 pb-3 text-white">Training Setup</h2>

                <div class="space-y-5">
                    <div class="form-group">
                        <label for="player-color-select" class="block text-sm font-medium text-slate-300 mb-2">Your Color:</label>
                        <select id="player-color-select" class="form-select w-full p-2.5 rounded-lg text-white" aria-label="Select your color">
                            <option value="w">White</option>
                            <option value="b">Black</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="category-select" class="block text-sm font-medium text-slate-300 mb-2">Opening Category:</label>
                        <select id="category-select" class="form-select w-full p-2.5 rounded-lg text-white" aria-label="Select opening category"></select>
                    </div>
                     <div class="form-group">
                        <label for="opening-select" class="block text-sm font-medium text-slate-300 mb-2">Specific Opening:</label>
                        <select id="opening-select" class="form-select w-full p-2.5 rounded-lg text-white" aria-label="Select specific opening"></select>
                    </div>
                     <div class="form-group">
                        <label for="variation-select" class="block text-sm font-medium text-slate-300 mb-2">Variation:</label>
                        <select id="variation-select" class="form-select w-full p-2.5 rounded-lg text-white" aria-label="Select opening variation"></select>
                    </div>
                </div>

                <div class="button-grid mt-6">
                    <button id="start-btn" class="btn start-btn w-full py-3 px-4 rounded-lg font-semibold text-white shadow-lg" role="button">Start Practice</button>
                    <button id="undo-btn" class="btn undo-btn w-full py-3 px-4 rounded-lg font-semibold text-white" role="button">Undo Last Move</button>
                    <button id="reset-btn" class="btn w-full py-3 px-4 rounded-lg font-semibold text-white" role="button">Reset Board</button>
                    <button id="start-bot-btn" class="btn start-bot-btn w-full py-3 px-4 rounded-lg font-semibold text-white shadow-lg col-span-2" style="display: none;" role="button">Start Two-Player Mode</button>
                </div>
            </section>

            <section class="board-section" aria-labelledby="game-status-heading">
                        <div id="status" class="w-full p-4 mb-4 bg-slate-800 rounded-lg text-center shadow-md">
            <h2 id="game-status-heading" class="sr-only">Game Status</h2>
            <p class="font-semibold text-xl" id="status-opening">Welcome!</p>
            <p class="text-md text-slate-400" id="status-move">Select an opening and start your practice.</p>
            <div id="evaluation-display" class="mt-2 text-sm"></div>
            <div id="selection-info" class="mt-2 text-sm text-blue-400" style="display: none;"></div>
        </div>
                <div class="board-container">
                    <div id="myBoard" class="w-full rounded-lg shadow-2xl"></div>
                    <div class="tips-section">
                        <p>💡 <strong>Tip:</strong> Click a piece to select it, then click where you want to move it.</p>
                        <p>Or use drag and drop. Press ESC to deselect.</p>
                    </div>
                </div>
            </section>
        </div>
    </main>



    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.min.js"></script>

    <script>
        // All JavaScript is here
        // Use jQuery's ready function for more reliable DOM loading
        $(function() { 
            // --- Interactive Aura Effect ---
            const body = document.body;
            const updateAura = (x, y) => {
                body.style.setProperty('--mouse-x', `${x}px`);
                body.style.setProperty('--mouse-y', `${y}px`);
            };
            document.addEventListener('mousemove', e => updateAura(e.clientX, e.clientY));
            document.addEventListener('touchmove', e => e.touches.length > 0 && updateAura(e.touches[0].clientX, e.touches[0].clientY));
            document.addEventListener('touchstart', e => e.touches.length > 0 && updateAura(e.touches[0].clientX, e.touches[0].clientY));

            // --- Chess Logic ---
            if (typeof window.jQuery === 'undefined') {
                alert("Error: jQuery library failed to load. Please check your internet connection and refresh.");
                return;
            }

            const $ = window.jQuery;

            // Game state variables
            let board = null;
            let game = new Chess();
            let currentOpeningMoves = [];
            let currentMoveIndex = 0;
            let playerColor = 'w'; 
            let twoPlayerModeActive = false;
            let thinkingProcess = null;

            // DOM Elements
            const $statusOpening = $('#status-opening');
            const $statusMove = $('#status-move');
            const $boardElement = $('#myBoard');
            const $playerColorSelect = $('#player-color-select');
            const $categorySelect = $('#category-select');
            const $openingSelect = $('#opening-select');
            const $variationSelect = $('#variation-select');
            const $startBtn = $('#start-btn');
            const $resetBtn = $('#reset-btn');
            const $undoBtn = $('#undo-btn'); 
            const $startTwoPlayerBtn = $('#start-bot-btn');
            const $evaluationDisplay = $('#evaluation-display');
            const $selectionInfo = $('#selection-info');
            
            // Ensure board has relative positioning for proper arrow alignment
            $boardElement.css('position', 'relative');

            // --- Opening Book Data ---
            const openingBook = {
                "King's Pawn (e4)": {
                    "Italian Game": {
                        "Giuoco Piano": ['e4', 'e5', 'Nf3', 'Nc6', 'Bc4', 'Bc5', 'c3', 'Nf6', 'd4', 'exd4', 'cxd4', 'Bb4+', 'Nc3', 'Nxe4', 'O-O', 'Bxc3+', 'bxc3', 'd5', 'Bd3', 'O-O', 'c4'],
                        "Evans Gambit": ['e4', 'e5', 'Nf3', 'Nc6', 'Bc4', 'Bc5', 'b4', 'Bxb4', 'c3', 'Ba5', 'd4', 'exd4', 'O-O', 'dxc3', 'Qb3', 'Qf6', 'e5', 'Qg6', 'Nxc3', 'Nge7'],
                        "Fried Liver Attack": ['e4', 'e5', 'Nf3', 'Nc6', 'Bc4', 'Nf6', 'Ng5', 'd5', 'exd5', 'Nxd5', 'Nxf7', 'Kxf7', 'Qf3+', 'Ke6', 'Nc3', 'Ncb4', 'a3', 'Nxc2+', 'Kd1']
                    },
                    "Ruy Lopez": {
                        "Morphy Defense": ['e4', 'e5', 'Nf3', 'Nc6', 'Bb5', 'a6', 'Ba4', 'Nf6', 'O-O', 'Be7', 'Re1', 'b5', 'Bb3', 'd6', 'c3', 'O-O', 'h3', 'Na5', 'Bc2', 'c5'],
                        "Exchange Variation": ['e4', 'e5', 'Nf3', 'Nc6', 'Bb5', 'a6', 'Bxc6', 'dxc6', 'O-O', 'f6', 'd4', 'exd4', 'Nxd4', 'Ne7', 'Re1', 'Ng6', 'Nd2', 'c5'],
                        "Berlin Defense": ['e4', 'e5', 'Nf3', 'Nc6', 'Bb5', 'Nf6', 'O-O', 'Nxe4', 'd4', 'Nd6', 'Bxc6', 'dxc6', 'dxe5', 'Nf5', 'Qxd8+', 'Kxd8', 'Nc3', 'Ke8']
                    },
                    "Scotch Game": {
                        "Main Line": ['e4', 'e5', 'Nf3', 'Nc6', 'd4', 'exd4', 'Nxd4', 'Nf6', 'Nc3', 'Bb4', 'Nxc6', 'bxc6', 'Bd3', 'd5', 'exd5', 'cxd5', 'O-O'],
                        "Scotch Gambit": ['e4', 'e5', 'Nf3', 'Nc6', 'd4', 'exd4', 'Bc4', 'Nf6', 'O-O', 'Nxe4', 'Re1', 'd5', 'Bxd5', 'Qxd5', 'Nc3']
                    },
                    "Petrov Defense": {
                        "Classical Variation": ['e4', 'e5', 'Nf3', 'Nf6', 'Nxe5', 'd6', 'Nf3', 'Nxe4', 'd4', 'd5', 'Bd3', 'Bd6', 'O-O', 'O-O', 'c4', 'c6', 'Re1'],
                        "Modern Attack": ['e4', 'e5', 'Nf3', 'Nf6', 'Nxe5', 'd6', 'Nf3', 'Nxe4', 'Nc3', 'Nxc3', 'dxc3', 'Be7', 'Bd3', 'O-O', 'O-O']
                    },
                    "Sicilian Defense": {
                        "Najdorf Variation": ['e4', 'c5', 'Nf3', 'd6', 'd4', 'cxd4', 'Nxd4', 'Nf6', 'Nc3', 'a6', 'Be3', 'e5', 'Nb3', 'Be7', 'f3', 'Be6', 'Qd2', 'O-O', 'O-O-O'],
                        "Dragon Variation": ['e4', 'c5', 'Nf3', 'd6', 'd4', 'cxd4', 'Nxd4', 'Nf6', 'Nc3', 'g6', 'Be3', 'Bg7', 'f3', 'Nc6', 'Qd2', 'O-O', 'Bc4', 'Nxd4', 'Bxd4', 'Bd7', 'O-O-O'],
                        "Accelerated Dragon": ['e4', 'c5', 'Nf3', 'Nc6', 'd4', 'cxd4', 'Nxd4', 'g6', 'Nc3', 'Bg7', 'Be3', 'Nf6', 'Bc4', 'O-O', 'Bb3', 'd6', 'f3'],
                        "Open Sicilian (e6)": ['e4', 'c5', 'Nf3', 'e6', 'd4', 'cxd4', 'Nxd4', 'Nf6', 'Nc3', 'Nc6', 'Ndb5', 'd6', 'Bf4', 'e5', 'Bg5', 'a6', 'Na3'],
                        "Alapin Variation": ['e4', 'c5', 'c3', 'Nf6', 'e5', 'Nd5', 'd4', 'cxd4', 'cxd4', 'd6', 'Nf3', 'Nc6', 'Bc4', 'e6', 'O-O']
                    },
                    "French Defense": {
                        "Advance Variation": ['e4', 'e6', 'd4', 'd5', 'e5', 'c5', 'c3', 'Nc6', 'Nf3', 'Bd7', 'Be2', 'Nge7', 'O-O', 'Nf5', 'Bd3'],
                        "Exchange Variation": ['e4', 'e6', 'd4', 'd5', 'exd5', 'exd5', 'Nf3', 'Nf6', 'Bd3', 'Bd6', 'O-O', 'O-O', 'c3', 'Re8', 'Re1'],
                        "Winawer Variation": ['e4', 'e6', 'd4', 'd5', 'Nc3', 'Bb4', 'e5', 'c5', 'a3', 'Bxc3+', 'bxc3', 'Ne7', 'Qg4', 'Qc7', 'Qxg7', 'Rg8', 'Qxh7'],
                        "Classical Variation": ['e4', 'e6', 'd4', 'd5', 'Nc3', 'Nf6', 'Bg5', 'Be7', 'e5', 'Nfd7', 'Bxe7', 'Qxe7', 'f4', 'a6', 'Nf3']
                    },
                    "Caro-Kann Defense": {
                        "Classical Variation": ['e4', 'c6', 'd4', 'd5', 'Nc3', 'dxe4', 'Nxe4', 'Bf5', 'Ng3', 'Bg6', 'h4', 'h6', 'Nf3', 'e6', 'Be2'],
                        "Advance Variation": ['e4', 'c6', 'd4', 'd5', 'e5', 'Bf5', 'Nf3', 'e6', 'Be2', 'c5', 'c3', 'Nc6', 'O-O', 'Qb6', 'a3'],
                        "Panov-Botvinnik Attack": ['e4', 'c6', 'd4', 'd5', 'exd5', 'cxd5', 'c4', 'Nf6', 'Nc3', 'Nc6', 'Bg5', 'e6', 'Nf3', 'Bb4', 'cxd5', 'exd5']
                    }
                },
                "Queen's Pawn (d4)": {
                    "Queen's Gambit": {
                        "Accepted": ['d4', 'd5', 'c4', 'dxc4', 'Nf3', 'Nf6', 'e3', 'e6', 'Bxc4', 'c5', 'O-O', 'a6', 'dxc5', 'Bxc5', 'Qe2'],
                        "Declined": ['d4', 'd5', 'c4', 'e6', 'Nc3', 'Nf6', 'Bg5', 'Be7', 'e3', 'O-O', 'Nf3', 'Nbd7', 'Bd3', 'c6', 'O-O', 'h6', 'Bh4'],
                        "Tarrasch Defense": ['d4', 'd5', 'c4', 'e6', 'Nc3', 'c5', 'cxd5', 'exd5', 'Nf3', 'Nc6', 'g3', 'Nf6', 'Bg2', 'Be7', 'O-O'],
                        "Slav Defense": ['d4', 'd5', 'c4', 'c6', 'Nc3', 'Nf6', 'Nf3', 'e6', 'e3', 'Nbd7', 'Bd3', 'dxc4', 'Bxc4', 'b5', 'Bd3'],
                        "Semi-Slav Defense": ['d4', 'd5', 'c4', 'c6', 'Nf3', 'Nf6', 'Nc3', 'e6', 'e3', 'Nbd7', 'Bd3', 'dxc4', 'Bxc4', 'Bd6', 'O-O']
                    },
                    "London System": {
                        "Main Line": ['d4', 'd5', 'Bf4', 'Nf6', 'e3', 'c5', 'c3', 'Nc6', 'Nd2', 'Qb6', 'Rb1', 'Bf5', 'Ngf3', 'e6', 'Qb3'],
                        "Jobava London": ['d4', 'Nf6', 'Nc3', 'd5', 'Bf4', 'Bf5', 'e3', 'e6', 'Nf3', 'c6', 'Ne5', 'Nbd7', 'g4', 'Nxe5', 'gxf5']
                    },
                    "King's Indian Defense": {
                        "Classical Variation": ['d4', 'Nf6', 'c4', 'g6', 'Nc3', 'Bg7', 'e4', 'd6', 'Nf3', 'O-O', 'Be2', 'e5', 'O-O', 'Nc6', 'd5', 'Ne7', 'Ne1', 'Nd7'],
                        "Sämisch Variation": ['d4', 'Nf6', 'c4', 'g6', 'Nc3', 'Bg7', 'e4', 'd6', 'f3', 'O-O', 'Be3', 'c5', 'd5', 'e6', 'Bd3'],
                        "Fianchetto Variation": ['d4', 'Nf6', 'c4', 'g6', 'g3', 'Bg7', 'Bg2', 'd6', 'Nf3', 'O-O', 'Nc3', 'Nbd7', 'O-O', 'e5', 'e4']
                    },
                    "Nimzo-Indian Defense": {
                        "Rubinstein Variation": ['d4', 'Nf6', 'c4', 'e6', 'Nc3', 'Bb4', 'e3', 'O-O', 'Nf3', 'd5', 'Bd3', 'c5', 'O-O', 'dxc4', 'Bxc4'],
                        "Classical Variation": ['d4', 'Nf6', 'c4', 'e6', 'Nc3', 'Bb4', 'Qc2', 'd5', 'a3', 'Bxc3+', 'Qxc3', 'c5', 'dxc5', 'Nbd7', 'cxd5'],
                        "Leningrad Variation": ['d4', 'Nf6', 'c4', 'e6', 'Nc3', 'Bb4', 'Bg5', 'h6', 'Bh4', 'c5', 'e3', 'g5', 'Bg3']
                    },
                    "Grünfeld Defense": {
                        "Exchange Variation": ['d4', 'Nf6', 'c4', 'g6', 'Nc3', 'd5', 'cxd5', 'Nxd5', 'e4', 'Nxc3', 'bxc3', 'Bg7', 'Bc4', 'c5', 'Ne2', 'Nc6', 'Be3'],
                        "Russian System": ['d4', 'Nf6', 'c4', 'g6', 'Nc3', 'd5', 'Qb3', 'dxc4', 'Qxc4', 'Bg7', 'e4', 'O-O', 'Nf3', 'c6', 'Be2']
                    },
                    "Benoni Defense": {
                        "Modern Benoni": ['d4', 'Nf6', 'c4', 'c5', 'd5', 'e6', 'Nc3', 'exd5', 'cxd5', 'd6', 'e4', 'g6', 'Nf3', 'Bg7', 'Be2', 'O-O', 'O-O'],
                        "Czech Benoni": ['d4', 'c5', 'd5', 'e5', 'e4', 'd6', 'Nc3', 'Nf6', 'f4', 'exf4', 'Bxf4', 'Be7', 'Nf3']
                    }
                },
                "Flank Openings": {
                    "English Opening": {
                        "Symmetrical Variation": ['c4', 'c5', 'Nc3', 'Nc6', 'g3', 'g6', 'Bg2', 'Bg7', 'Nf3', 'Nf6', 'O-O', 'O-O', 'Rb1', 'd6', 'a3'],
                        "Reversed Sicilian": ['c4', 'e5', 'Nc3', 'Nf6', 'g3', 'd5', 'cxd5', 'Nxd5', 'Bg2', 'Be6', 'Nf3', 'Nc6', 'O-O', 'Be7', 'd3'],
                        "Four Knights Variation": ['c4', 'e5', 'Nc3', 'Nf6', 'Nf3', 'Nc6', 'g3', 'Bb4', 'Bg2', 'O-O', 'O-O', 'Re8', 'Nd5', 'Nxd5', 'cxd5', 'e4', 'Ne1']
                    },
                    "Réti Opening": {
                        "Main Line": ['Nf3', 'd5', 'c4', 'd4', 'b4', 'f6', 'e3', 'e5', 'exd4', 'exd4', 'Bd3', 'Bxb4', 'O-O', 'Ne7', 'Nbd2'],
                        "King's Indian Attack": ['Nf3', 'Nf6', 'g3', 'd5', 'Bg2', 'c5', 'O-O', 'Nc6', 'd3', 'e5', 'Nbd2', 'Be7', 'e4', 'd4', 'a4']
                    },
                    "Bird's Opening": {
                        "Main Line": ['f4', 'd5', 'Nf3', 'Nf6', 'e3', 'e6', 'b3', 'c5', 'Bb2', 'Nc6', 'Bb5', 'Bd7', 'O-O'],
                        "From Gambit": ['f4', 'e5', 'fxe5', 'd6', 'exd6', 'Bxd6', 'Nf3', 'g5', 'g3', 'g4', 'Nd4', 'Be5', 'e3']
                    },
                    "Larsen's Opening": {
                        "Main Line": ['b3', 'e5', 'Bb2', 'Nc6', 'e3', 'Nf6', 'Bb5', 'Bd6', 'Ne2', 'O-O', 'O-O', 'Re8', 'Ng3'],
                        "Modern Variation": ['b3', 'd5', 'Bb2', 'Nf6', 'Nf3', 'c5', 'e3', 'Nc6', 'Bb5', 'Bd7', 'O-O', 'e6', 'Bxc6', 'Bxc6']
                    }
                },
                "Indian Defenses (Other)": {
                    "Queen's Indian Defense": {
                        "Main Line": ['d4', 'Nf6', 'c4', 'e6', 'Nf3', 'b6', 'g3', 'Bb7', 'Bg2', 'Be7', 'O-O', 'O-O', 'Nc3', 'Ne4', 'Bd2'],
                        "Nimzowitsch Variation": ['d4', 'Nf6', 'c4', 'e6', 'Nf3', 'b6', 'Nc3', 'Bb7', 'Bg5', 'Be7', 'e3', 'O-O', 'Be2']
                    },
                    "Bogo-Indian Defense": {
                        "Main Line": ['d4', 'Nf6', 'c4', 'e6', 'Nf3', 'Bb4+', 'Bd2', 'a5', 'g3', 'd6', 'Bg2', 'Bxd2+', 'Qxd2', 'O-O', 'Nc3'],
                        "Queen-side Fianchetto": ['d4', 'Nf6', 'c4', 'e6', 'Nf3', 'Bb4+', 'Nbd2', 'O-O', 'a3', 'Bxd2+', 'Qxd2', 'b6', 'g3']
                    }
                }
            };

            /**
             * Populates the category dropdown with the main opening categories.
             */
            function populateCategories() {
                $categorySelect.empty();
                for (const category in openingBook) { $categorySelect.append($('<option>', { value: category, text: category })); }
                $categorySelect.trigger('change');
            }

            /**
             * Populates the opening dropdown based on the selected category.
             */
            function populateOpenings() {
                const selectedCategory = $categorySelect.val();
                $openingSelect.empty();
                if (openingBook[selectedCategory]) {
                    for (const opening in openingBook[selectedCategory]) { $openingSelect.append($('<option>', { value: opening, text: opening })); }
                }
                $openingSelect.trigger('change');
            }

            /**
             * Populates the variation dropdown based on the selected opening.
             */
            function populateVariations() {
                const selectedCategory = $categorySelect.val();
                const selectedOpening = $openingSelect.val();
                $variationSelect.empty();
                if(openingBook[selectedCategory] && openingBook[selectedCategory][selectedOpening]) {
                    for (const variation in openingBook[selectedCategory][selectedOpening]) { $variationSelect.append($('<option>', { value: variation, text: variation })); }
                }
            }

            $categorySelect.on('change', populateOpenings);
            $openingSelect.on('change', populateVariations);

            /**
             * Displays a status message in the evaluation display area.
             * @param {string} [statusMessage=null] - The message to display.
             */
            function displayEvaluation(statusMessage = null) {
                $evaluationDisplay.empty().removeClass('eval-white eval-black eval-even');

                if (statusMessage) { 
                    $evaluationDisplay.text(statusMessage);
                } else {
                    $evaluationDisplay.text('Game In Progress'); 
                }
            }

            // --- Click-to-Move and Highlighting Variables ---
            let squareSelected = null; 
            let legalMovesForSelectedPiece = [];

            /**
             * Updates the selection info display.
             * @param {string} [message=null] - The message to display, or null to hide the display.
             */
            function updateSelectionInfo(message = null) {
                if (message) {
                    $selectionInfo.text(message).show();
                } else {
                    $selectionInfo.hide();
                }
            }

            /**
             * Clears all visual highlights from the board (selection, legal moves, check, etc.).
             */
            function clearHighlights() {
                $('#myBoard .square-55d63').removeClass('highlight-selected highlight-check highlight-checkmate-winner highlight-checkmate-loser');
                legalMovesForSelectedPiece.forEach(move => {
                    $('#myBoard .square-' + move.to).removeClass('highlight-legal-move');
                });
                updateSelectionInfo(null);
            }

            /**
             * Clears any arrows from the board.
             */
            function clearArrow() {
                $('.arrow').remove();
                // Also clean up any arrowhead markers that might be left in defs
                $('defs').find('[id^="arrowhead-"]').remove();
            }

            /**
             * Draws an arrow on the board from a starting square to an ending square.
             * @param {string} from - The starting square in algebraic notation (e.g., 'e2').
             * @param {string} to - The ending square in algebraic notation (e.g., 'e4').
             */
            function drawArrow(from, to) {
                clearArrow();
                const boardElement = $('#myBoard');
                const boardPosition = boardElement.position();
                const boardRect = boardElement[0].getBoundingClientRect();
                const squareWidth = boardRect.width / 8;
                const squareHeight = boardRect.height / 8;
                
                // Convert algebraic notation to coordinates
                const fromFile = from.charCodeAt(0) - 'a'.charCodeAt(0);
                const fromRank = 8 - parseInt(from.charAt(1));
                const toFile = to.charCodeAt(0) - 'a'.charCodeAt(0);
                const toRank = 8 - parseInt(to.charAt(1));
                
                // Calculate centers based on square position within the board
                const fromX = (fromFile + 0.5) * squareWidth;
                const fromY = (fromRank + 0.5) * squareHeight;
                const toX = (toFile + 0.5) * squareWidth;
                const toY = (toRank + 0.5) * squareHeight;

                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('class', 'arrow');
                svg.setAttribute('width', boardRect.width);
                svg.setAttribute('height', boardRect.height);
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';
                
                // Create unique ID for this arrow's marker to avoid conflicts
                const markerId = 'arrowhead-' + Date.now();

                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', markerId);
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '7');
                marker.setAttribute('refX', '7');
                marker.setAttribute('refY', '3.5');
                marker.setAttribute('orient', 'auto');
                
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                marker.appendChild(polygon);
                defs.appendChild(marker);
                svg.appendChild(defs);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromX);
                line.setAttribute('y1', fromY);
                line.setAttribute('x2', toX);
                line.setAttribute('y2', toY);
                line.setAttribute('marker-end', 'url(#' + markerId + ')');
                svg.appendChild(line);

                boardElement.append(svg);
            }

            /**
             * Updates the board to highlight the king if it is in check.
             */
            function updateHighlights() {
                clearHighlights();
                if (game.in_check()) {
                    const kingSquare = findKing(game.turn());
                    $('#myBoard .square-' + kingSquare).addClass('highlight-check');
                }
            }

            /**
             * Finds the square of the king for a given color.
             * @param {string} color - The color of the king to find ('w' or 'b').
             * @returns {string|null} The square of the king or null if not found.
             */
            function findKing(color) {
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const square = 'abcdefgh'[j] + (i + 1);
                        const piece = game.get(square);
                        if (piece && piece.type === 'k' && piece.color === color) {
                            return square;
                        }
                    }
                }
                return null;
            }

            /**
             * Handles the logic for when a square is clicked on the board.
             * @param {string} square - The square that was clicked.
             */
            function onSquareClick(square) {
                clearArrow();
                if (game.game_over()) {
                    updateStatus("Game is over!", false);
                    return;
                }

                if (currentMoveIndex < currentOpeningMoves.length) {
                    if (game.turn() !== playerColor) {
                        updateStatus("It's not your turn to play book moves! You are White.", false);
                        return;
                    }
                    handlePlayerMoveInBookMode(square);
                    return;
                }

                if (squareSelected === null) {
                    let piece = game.get(square);
                    if (piece && piece.color === game.turn()) {
                        squareSelected = square;
                        $('#myBoard .square-' + square).addClass('highlight-selected');
                        legalMovesForSelectedPiece = game.moves({ square: square, verbose: true });
                        legalMovesForSelectedPiece.forEach(move => {
                            $('#myBoard .square-' + move.to).addClass('highlight-legal-move');
                        });
                        updateSelectionInfo(`Selected ${piece.type.toUpperCase()} on ${square}. Click destination square or press ESC to deselect.`);
                        updateStatus(`Piece selected.`);
                    }
                } else if (squareSelected === square) {
                    // Clicking on the same piece deselects it
                    clearHighlights();
                    squareSelected = null;
                    legalMovesForSelectedPiece = [];
                    updateStatus('Piece deselected. Click on a piece to select it.');
                } else {
                    let move = game.move({
                        from: squareSelected,
                        to: square,
                        promotion: 'q'
                    });

                    clearHighlights();

                    if (move === null) {
                        squareSelected = null;
                        legalMovesForSelectedPiece = [];
                        updateStatus("Illegal move! Try again.", false);
                        board.position(game.fen());
                        return;
                    } else {
                        squareSelected = null;
                        legalMovesForSelectedPiece = [];
                        board.position(game.fen());
                        updateStatus(`Move: ${move.san}`);
                        updateHighlights();
                        if (!game.game_over()) {
                            if (game.turn() === playerColor) {
                                $statusMove.text(`Player ${game.turn() === 'w' ? 'White' : 'Black'}'s turn.`);
                            } else if (twoPlayerModeActive) {
                                // Computer's turn after opening
                                setTimeout(makeComputerMove, 500);
                            } else {
                                $statusMove.text(`Player ${game.turn() === 'w' ? 'White' : 'Black'}'s turn.`);
                            }
                        } else {
                            handleGameOver();
                        }
                    }
                }
            }

            /**
             * Handles player moves during the opening practice phase.
             * @param {string} source - The source square of the move.
             * @param {string} [target=null] - The target square of the move (for drag-and-drop).
             */
            function handlePlayerMoveInBookMode(source, target = null) {
                clearArrow();
                let moveResult;
                const currentFenBeforeMove = game.fen();

                if (target === null) {
                    let square = source;
                    if (squareSelected === null) {
                        let piece = game.get(square);
                        if (piece && piece.color === game.turn()) {
                            squareSelected = square;
                            $('#myBoard .square-' + square).addClass('highlight-selected');
                            legalMovesForSelectedPiece = game.moves({ square: square, verbose: true });
                            legalMovesForSelectedPiece.forEach(move => {
                                $('#myBoard .square-' + move.to).addClass('highlight-legal-move');
                            });
                            updateSelectionInfo(`Selected ${piece.type.toUpperCase()} on ${square}. Click destination square or press ESC to deselect.`);
                            updateStatus(`Piece selected.`);
                        }
                        return;
                    } else if (squareSelected === square) {
                        // Clicking on the same piece deselects it
                        clearHighlights();
                        squareSelected = null;
                        legalMovesForSelectedPiece = [];
                        updateStatus('Piece deselected. Click on a piece to select it.');
                        return;
                    }

                    moveResult = game.move({ from: squareSelected, to: square, promotion: 'q' });
                    clearHighlights();
                    squareSelected = null;
                } else {
                    moveResult = game.move({ from: source, to: target, promotion: 'q' });
                }

                if (moveResult === null) {
                    updateStatus("Illegal move! Try again.", false);
                    board.position(game.fen());
                    return 'snapback';
                }
                
                board.position(game.fen());
                updateHighlights();

                const correctMoveSAN = currentOpeningMoves[currentMoveIndex];
                
                if (moveResult.san === correctMoveSAN) {
                    currentMoveIndex++;
                    updateStatus(`Correct! Move: ${moveResult.san} <span class="highlight-correct">(Book Move)</span>`, true);

                    if (currentMoveIndex < currentOpeningMoves.length) {
                        setTimeout(makeComputerMoveInBookMode, 500);
                    } else {
                        updateStatus("Opening complete! Now playing against computer...", true);
                        twoPlayerModeActive = true;
                        $startTwoPlayerBtn.hide();
                        // Continue with computer moves after opening
                        if (game.turn() !== playerColor) {
                            setTimeout(makeComputerMove, 500);
                        } else {
                            updateStatus('Your turn.');
                        }
                    }
                    return true;
                } else {
                    updateStatus(`Incorrect. The book move is ${correctMoveSAN}. Try again.`, false);
                    const tempGame = new Chess(currentFenBeforeMove);
                    const correctMove = tempGame.move(correctMoveSAN);
                    drawArrow(correctMove.from, correctMove.to);
                    game.undo();
                    board.position(game.fen());
                    return 'snapback';
                }
            }

            /**
             * Handles the drop event for drag-and-drop moves.
             * @param {string} source - The source square.
             * @param {string} target - The target square.
             */
            function onDrop(source, target) {
                clearArrow();
                if (game.game_over()) {
                    updateStatus("Game is over!", false);
                    return 'snapback';
                }
                
                if (currentMoveIndex < currentOpeningMoves.length) {
                    if (game.turn() !== playerColor) {
                        updateStatus("It's not your turn to play book moves! You are White.", false);
                        return 'snapback';
                    }
                    return handlePlayerMoveInBookMode(source, target);
                } 
                
                if (game.get(source) && game.get(source).color !== game.turn()) {
                    updateStatus(`It's not ${game.turn() === 'w' ? 'White' : 'Black'}'s turn!`, false);
                    return 'snapback';
                }

                let move = game.move({ from: source, to: target, promotion: 'q' });

                if (move === null) {
                    updateStatus("Illegal move! Try again.", false);
                    return 'snapback';
                }
                
                board.position(game.fen());
                updateStatus(`Move: ${move.san}`);
                updateHighlights();
                if (!game.game_over()) {
                    if (game.turn() === playerColor) {
                        $statusMove.text(`Player ${game.turn() === 'w' ? 'White' : 'Black'}'s turn.`);
                    } else if (twoPlayerModeActive) {
                        // Computer's turn after opening
                        setTimeout(makeComputerMove, 500);
                    } else {
                        $statusMove.text(`Player ${game.turn() === 'w' ? 'White' : 'Black'}'s turn.`);
                    }
                } else {
                    handleGameOver();
                }
                return true; 
            }

            /**
             * Makes the next move for the computer during the opening practice.
             */
            function makeComputerMoveInBookMode() {
                if (game.game_over()) {
                    handleGameOver();
                    return;
                }
                if (game.turn() !== playerColor && currentMoveIndex < currentOpeningMoves.length) {
                    const moveSAN = currentOpeningMoves[currentMoveIndex];
                    const moveResult = game.move(moveSAN, { sloppy: true });
                    if (moveResult === null) {
                        console.error("Computer tried to make an illegal move (from book):", moveSAN, "from FEN:", game.fen());
                        updateStatus("Error in opening data! Computer tried an illegal move. Reset board.", false);
                        return;
                    }
                    board.position(game.fen());
                    updateHighlights();
                    currentMoveIndex++;
                    updateStatus(`Computer plays: ${moveSAN} <span class="feedback-book">(Book Move)</span>`);
                    
                    if (currentMoveIndex >= currentOpeningMoves.length) {
                        updateStatus("Opening complete! Now playing against computer...", true);
                        twoPlayerModeActive = true; 
                        $startTwoPlayerBtn.hide();
                        // Continue with computer moves after opening
                        if (game.turn() !== playerColor) {
                            setTimeout(makeComputerMove, 500);
                        } else {
                            updateStatus('Your turn.');
                        }
                    } else if (game.turn() === playerColor) {
                        updateStatus('Your turn.');
                    } else {
                        setTimeout(makeComputerMoveInBookMode, 500);
                    }
                } else {
                    console.log("Not computer's book move turn. Skipping makeComputerMoveInBookMode.");
                }
            }

            // --- Chess Master Engine: Advanced Opening Book + Strong Search ---
            const ENGINE_CONFIG = {
                maxDepth: 6,
                maxThinkTimeMs: 1000,
                quiescenceMaxDepth: 10,
                enableQuiescence: true,
                useOpeningBook: true,
                useEndgameTablebase: true
            };
            
            // Opening book for common positions
            const openingBookMoves = {
                // Starting position
                "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -": ["e4", "d4", "Nf3"],
                // After 1.e4
                "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3": ["c5", "e5", "e6", "c6"],
                // After 1.d4
                "rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq d3": ["Nf6", "d5", "e6"],
                // Common Sicilian
                "rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6": ["Nf3", "Nc3"],
                // Common e5 response
                "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6": ["Nf3", "Bc4"]
            };
            
            // Endgame tablebase for common positions
            const endgameTablebase = {
                // King and queen vs king
                "K and Q vs K": (fen) => {
                    // Logic to find optimal moves in KQ vs K endgames
                    return null; // Will use search if no tablebase move found
                },
                // King and rook vs king
                "K and R vs K": (fen) => {
                    // Logic for KR vs K endgames
                    return null;
                }
            };
            
            let tt = new Map(); // Transposition table keyed by FEN
            let killerMoves = {}; // ply -> [{from,to,promotion}, {..}]
            let historyHeuristic = {}; // key "from_to" -> score
            let searchAbortTime = 0;
            let searchAborted = false;
            let nodesVisited = 0;
            
            // Store best moves found to avoid repeating search
            let cachedBestMoves = new Map();

            function resetSearchState() {
                tt.clear();
                killerMoves = {};
                historyHeuristic = {};
                searchAborted = false;
                nodesVisited = 0;
            }

            const INF = 1e9;
            const MATE_SCORE = 1000000;
            const PIECE_VALUES = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 0 };

            function pieceSquareScore(piece, fileIdx, rankIdx, isEndgame) {
                // Simple piece-square tables (center preference); values are modest
                const centerBonus = ([3,4].includes(fileIdx) && [3,4].includes(rankIdx)) ? 10 : 0;
                if (piece.type === 'p') return 5 * (piece.color === 'w' ? rankIdx : (7 - rankIdx)) + centerBonus;
                if (piece.type === 'n') return 5 + centerBonus * 2;
                if (piece.type === 'b') return 5 + centerBonus * 2;
                if (piece.type === 'r') return 2 + centerBonus;
                if (piece.type === 'q') return centerBonus;
                if (piece.type === 'k') return isEndgame ? centerBonus * 2 : 0;
                return 0;
            }

            function isEndgameLike() {
                // Rough heuristic: endgame if queens are off or total material < threshold
                let total = 0;
                for (let r = 1; r <= 8; r++) {
                    for (let f = 0; f < 8; f++) {
                        const sq = 'abcdefgh'[f] + r;
                        const pc = game.get(sq);
                        if (!pc) continue;
                        total += (PIECE_VALUES[pc.type] || 0);
                    }
                }
                return total < 2000 || !game.fen().includes('q');
            }

            function staticEvaluate() {
                // Material, piece-square tables, mobility, king safety, pawn structure
                let score = 0;
                const endgame = isEndgameLike();
                
                // Piece values and positioning
                for (let rank = 1; rank <= 8; rank++) {
                    for (let file = 0; file < 8; file++) {
                        const square = 'abcdefgh'[file] + rank;
                        const piece = game.get(square);
                        if (!piece) continue;
                        const sign = piece.color === 'w' ? 1 : -1;
                        score += sign * ((PIECE_VALUES[piece.type] || 0) + pieceSquareScore(piece, file, rank - 1, endgame));
                    }
                }
                
                // Mobility - more moves is better
                const mobilityWhite = countMovesFor('w');
                const mobilityBlack = countMovesFor('b');
                score += 2 * (mobilityWhite - mobilityBlack);
                
                // King safety - penalize exposed king
                const whiteKingSquare = findKing('w');
                const blackKingSquare = findKing('b');
                if (whiteKingSquare && blackKingSquare) {
                    const whiteKingSafety = evaluateKingSafety(whiteKingSquare, 'w', endgame);
                    const blackKingSafety = evaluateKingSafety(blackKingSquare, 'b', endgame);
                    score += whiteKingSafety - blackKingSafety;
                }
                
                // Pawn structure - doubled, isolated, passed pawns
                const whitePawnStructure = evaluatePawnStructure('w');
                const blackPawnStructure = evaluatePawnStructure('b');
                score += whitePawnStructure - blackPawnStructure;
                
                // Control of center
                const whiteCenterControl = evaluateCenterControl('w');
                const blackCenterControl = evaluateCenterControl('b');
                score += whiteCenterControl - blackCenterControl;
                
                // Check status - being in check is bad
                if (game.in_check()) {
                    score += (game.turn() === 'w' ? -20 : 20);
                }
                
                // Convert to side-to-move perspective for negamax
                const sideSign = (game.turn() === 'w') ? 1 : -1;
                return sideSign * score;
            }
            
            function evaluateKingSafety(kingSquare, color, isEndgame) {
                if (!kingSquare) return 0;
                
                const file = kingSquare.charCodeAt(0) - 'a'.charCodeAt(0);
                const rank = parseInt(kingSquare.charAt(1)) - 1;
                
                let safety = 0;
                
                // In the opening/middlegame, king should stay back
                if (!isEndgame) {
                    // Penalize king in the center
                    if (file > 1 && file < 6) safety -= 30;
                    
                    // Reward king in the corner
                    if ((file <= 1 || file >= 6) && (rank <= 1 || rank >= 6)) safety += 20;
                    
                    // Reward king behind pawn shield
                    const pawnShield = countPawnShield(kingSquare, color);
                    safety += pawnShield * 15;
                } else {
                    // In endgame, king should move to center
                    if (file > 1 && file < 6 && rank > 1 && rank < 6) safety += 20;
                }
                
                return color === 'w' ? safety : -safety;
            }
            
            function countPawnShield(kingSquare, color) {
                const file = kingSquare.charCodeAt(0) - 'a'.charCodeAt(0);
                const rank = parseInt(kingSquare.charAt(1));
                
                let count = 0;
                const rankOffset = color === 'w' ? 1 : -1;
                const baseRank = color === 'w' ? rank + 1 : rank - 1;
                
                // Check pawns in front of king
                for (let f = Math.max(0, file - 1); f <= Math.min(7, file + 1); f++) {
                    const pawnSquare = 'abcdefgh'[f] + baseRank;
                    const piece = game.get(pawnSquare);
                    if (piece && piece.type === 'p' && piece.color === color) {
                        count++;
                    }
                }
                
                return count;
            }
            
            function evaluatePawnStructure(color) {
                let score = 0;
                const pawnPositions = [];
                const files = [0, 0, 0, 0, 0, 0, 0, 0]; // Count of pawns on each file
                
                // Find all pawns
                for (let rank = 1; rank <= 8; rank++) {
                    for (let file = 0; file < 8; file++) {
                        const square = 'abcdefgh'[file] + rank;
                        const piece = game.get(square);
                        if (piece && piece.type === 'p' && piece.color === color) {
                            pawnPositions.push({ file, rank });
                            files[file]++;
                        }
                    }
                }
                
                // Doubled pawns (bad)
                for (let i = 0; i < 8; i++) {
                    if (files[i] > 1) {
                        score -= 10 * (files[i] - 1);
                    }
                }
                
                // Isolated pawns (bad)
                for (let i = 0; i < 8; i++) {
                    if (files[i] > 0) {
                        const leftSupport = i > 0 ? files[i - 1] > 0 : false;
                        const rightSupport = i < 7 ? files[i + 1] > 0 : false;
                        if (!leftSupport && !rightSupport) {
                            score -= 15;
                        }
                    }
                }
                
                // Passed pawns (good)
                for (const pawn of pawnPositions) {
                    if (isPassed(pawn.file, pawn.rank, color)) {
                        const advancementBonus = color === 'w' ? pawn.rank : (9 - pawn.rank);
                        score += 10 + 5 * advancementBonus;
                    }
                }
                
                return color === 'w' ? score : -score;
            }
            
            function isPassed(file, rank, color) {
                const enemyColor = color === 'w' ? 'b' : 'w';
                const direction = color === 'w' ? 1 : -1;
                const startRank = color === 'w' ? rank + 1 : rank - 1;
                const endRank = color === 'w' ? 8 : 1;
                
                // Check if there are enemy pawns ahead or diagonally ahead
                for (let r = startRank; color === 'w' ? r <= endRank : r >= endRank; r += direction) {
                    // Check file and adjacent files
                    for (let f = Math.max(0, file - 1); f <= Math.min(7, file + 1); f++) {
                        const square = 'abcdefgh'[f] + r;
                        const piece = game.get(square);
                        if (piece && piece.type === 'p' && piece.color === enemyColor) {
                            return false;
                        }
                    }
                }
                
                return true;
            }
            
            function evaluateCenterControl(color) {
                const centerSquares = ['d4', 'e4', 'd5', 'e5'];
                let score = 0;
                
                // Count attacks on center squares
                for (const square of centerSquares) {
                    if (isSquareAttackedBy(square, color)) {
                        score += 5;
                    }
                }
                
                // Bonus for occupying center with pieces
                for (const square of centerSquares) {
                    const piece = game.get(square);
                    if (piece && piece.color === color) {
                        score += piece.type === 'p' ? 10 : 15;
                    }
                }
                
                return color === 'w' ? score : -score;
            }
            
            function isSquareAttackedBy(square, color) {
                // Use chess.js's built-in method if available
                if (typeof game.isAttacked === 'function') {
                    return game.isAttacked(square, color);
                }
                
                // Fallback: manually check if any piece of given color can move to the square
                const originalFen = game.fen();
                const parts = originalFen.split(' ');
                parts[1] = color;
                const fenForColor = parts.join(' ');
                const tempGame = new Chess(fenForColor);
                
                const moves = tempGame.moves({ verbose: true });
                return moves.some(m => m.to === square);
            }

            function countMovesFor(color) {
                // Quick mobility estimate by switching turn via FEN hack
                const originalFen = game.fen();
                const parts = originalFen.split(' ');
                parts[1] = color;
                const fenForColor = parts.join(' ');
                const tmp = new Chess(fenForColor);
                return tmp.moves().length;
            }

            function orderMoves(moves, ply) {
                // MVV-LVA + killer + history + checks ordering
                const scored = moves.map((m) => {
                    const isCapture = !!m.captured;
                    let score = 0;
                    if (isCapture) {
                        score += 10000 + (PIECE_VALUES[m.captured] || 0) - (PIECE_VALUES[m.piece] || 0);
                    }
                    // Killer
                    const killers = killerMoves[ply] || [];
                    if (killers.some(k => k.from === m.from && k.to === m.to && (k.promotion || 'q') === (m.promotion || 'q'))) {
                        score += 5000;
                    }
                    // History
                    const key = m.from + '_' + m.to;
                    score += (historyHeuristic[key] || 0);

                    // Quick check bonus: make and unmake
                    game.move({ from: m.from, to: m.to, promotion: m.promotion || 'q' });
                    if (game.in_check()) score += 3000;
                    game.undo();

                    return { move: m, score };
                });
                scored.sort((a, b) => b.score - a.score);
                return scored.map(s => s.move);
            }

            function estimateComplexity() {
                const moves = game.moves({ verbose: true });
                const hasTactical = moves.some(m => m.captured || m.promotion || (m.san && (m.san.includes('+') || m.san.includes('#'))));
                return { movesCount: moves.length, hasTactical };
            }

            function computeAllocatedTimeMs() {
                let t = ENGINE_CONFIG.maxThinkTimeMs;
                const info = estimateComplexity();
                if (game.in_check() || info.hasTactical || info.movesCount > 30) t += 400;
                if (info.movesCount > 40) t += 200;
                if (window.matchMedia && window.matchMedia('(hover: none) and (pointer: coarse)').matches) {
                    t = Math.min(t, 1000);
                }
                return t;
            }

            function qSearch(alpha, beta, qDepth) {
                if (Date.now() > searchAbortTime) { searchAborted = true; return alpha; }
                nodesVisited++;
                const standPat = staticEvaluate();
                if (standPat >= beta) return beta;
                if (alpha < standPat) alpha = standPat;
                if (!ENGINE_CONFIG.enableQuiescence || qDepth <= 0) return alpha;
                const moves = game.moves({ verbose: true }).filter(m => m.captured || m.promotion);
                if (moves.length === 0) return alpha;
                for (const m of orderMoves(moves, 0)) {
                    game.move({ from: m.from, to: m.to, promotion: m.promotion || 'q' });
                    const score = -qSearch(-beta, -alpha, qDepth - 1);
                    game.undo();
                    if (score >= beta) return beta;
                    if (score > alpha) alpha = score;
                }
                return alpha;
            }

            function negamax(depth, alpha, beta, ply) {
                if (Date.now() > searchAbortTime) { searchAborted = true; return 0; }
                nodesVisited++;

                // Terminal states
                if (game.in_checkmate()) return -(MATE_SCORE - ply);
                if (game.in_stalemate() || game.in_draw() || game.insufficient_material()) return 0;

                const ttKey = game.fen();
                const ttEntry = tt.get(ttKey);
                if (ttEntry && ttEntry.depth >= depth) {
                    if (ttEntry.flag === 'EXACT') return ttEntry.score;
                    if (ttEntry.flag === 'LOWER' && ttEntry.score > alpha) alpha = ttEntry.score;
                    else if (ttEntry.flag === 'UPPER' && ttEntry.score < beta) beta = ttEntry.score;
                    if (alpha >= beta) return ttEntry.score;
                }

                if (depth === 0) {
                    return qSearch(alpha, beta, ENGINE_CONFIG.quiescenceMaxDepth);
                }

                let bestScore = -INF;
                let bestLocalMove = null;
                let flag = 'UPPER';

                const moves = orderMoves(game.moves({ verbose: true }), ply);
                if (moves.length === 0) {
                    // No legal moves: already handled by checkmate/stalemate above
                    return staticEvaluate();
                }

                for (const m of moves) {
                    game.move({ from: m.from, to: m.to, promotion: m.promotion || 'q' });
                    const score = -negamax(depth - 1, -beta, -alpha, ply + 1);
                        game.undo();

                    if (searchAborted) return 0;

                    if (score > bestScore) {
                        bestScore = score;
                        bestLocalMove = m;
                    }
                    if (score > alpha) {
                        alpha = score;
                        flag = 'EXACT';
                        // History heuristic update
                        const key = m.from + '_' + m.to;
                        historyHeuristic[key] = (historyHeuristic[key] || 0) + depth * depth;
                    }
                    if (alpha >= beta) {
                        // Beta cutoff: store killer move
                        killerMoves[ply] = killerMoves[ply] || [];
                        killerMoves[ply].unshift({ from: m.from, to: m.to, promotion: m.promotion || 'q' });
                        if (killerMoves[ply].length > 2) killerMoves[ply].length = 2;
                        flag = 'LOWER';
                        break;
                    }
                }

                tt.set(ttKey, { depth, score: bestScore, flag });
                return bestScore;
            }

            // Check opening book for the current position
            function checkOpeningBook() {
                if (!ENGINE_CONFIG.useOpeningBook) return null;
                
                // Get a simplified FEN (just the position and side to move)
                const fen = game.fen();
                const simpleFen = fen.split(' ').slice(0, 3).join(' ');
                
                // Check if we have this position in our opening book
                for (const bookFen in openingBookMoves) {
                    if (fen.startsWith(bookFen) || simpleFen.startsWith(bookFen)) {
                        const bookMoves = openingBookMoves[bookFen];
                        // Try each book move in order
                        for (const moveStr of bookMoves) {
                            try {
                                // Validate move is legal in current position
                                const moveObj = game.move(moveStr);
                                game.undo(); // Don't actually make the move yet
                                if (moveObj) {
                                    console.log("Using opening book move:", moveStr);
                                    return moveObj;
                                }
                            } catch (e) {
                                // Move wasn't valid, try next one
                                console.log("Book move not valid:", moveStr);
                            }
                        }
                    }
                }
                return null;
            }
            
            // Check endgame tablebase
            function checkEndgameTablebase() {
                if (!ENGINE_CONFIG.useEndgameTablebase) return null;
                
                // Count pieces to see if we're in an endgame
                const fen = game.fen();
                const pieceCount = (fen.match(/[pnbrqkPNBRQK]/g) || []).length;
                
                if (pieceCount <= 5) {
                    // We're in an endgame with 5 or fewer pieces
                    // Check our tablebase
                    for (const endgameType in endgameTablebase) {
                        const tablebaseMove = endgameTablebase[endgameType](fen);
                        if (tablebaseMove) return tablebaseMove;
                    }
                }
                return null;
            }

            function findBestMoveIterative(thinkTimeMs) {
                // First check cache
                const fen = game.fen();
                if (cachedBestMoves.has(fen)) {
                    console.log("Using cached best move");
                    return cachedBestMoves.get(fen);
                }
                
                // Check opening book
                const bookMove = checkOpeningBook();
                if (bookMove) {
                    cachedBestMoves.set(fen, bookMove);
                    return bookMove;
                }
                
                // Check endgame tablebase
                const tablebaseMove = checkEndgameTablebase();
                if (tablebaseMove) {
                    cachedBestMoves.set(fen, tablebaseMove);
                    return tablebaseMove;
                }
                
                // Fall back to search
                resetSearchState();
                searchAbortTime = Date.now() + thinkTimeMs;
                let bestMove = null;
                let bestScore = -INF;
                
                // Get all legal moves
                const rootMoves = orderMoves(game.moves({ verbose: true }), 0);
                if (rootMoves.length === 0) return null;
                
                // If only one legal move, play it immediately
                if (rootMoves.length === 1) {
                    console.log("Only one legal move available");
                    return rootMoves[0];
                }
                
                // Iterative deepening search
                for (let depth = 1; depth <= ENGINE_CONFIG.maxDepth; depth++) {
                    let localBest = null;
                    let localBestScore = -INF;

                    for (const m of rootMoves) {
                        game.move({ from: m.from, to: m.to, promotion: m.promotion || 'q' });
                        const score = -negamax(depth - 1, -INF, INF, 1);
                        game.undo();
                        if (searchAborted) break;
                        if (score > localBestScore) {
                            localBestScore = score;
                            localBest = m;
                        }
                    }

                    if (!searchAborted && localBest) {
                        bestMove = localBest;
                        bestScore = localBestScore;
                        console.log(`Completed depth ${depth}, best move: ${bestMove.san}, score: ${bestScore}`);
                    } else {
                        break; // time ran out during this depth
                    }
                }
                
                // Cache the result
                if (bestMove) {
                    cachedBestMoves.set(fen, bestMove);
                }
                
                return bestMove;
            }

            function applyMoveSpec(m) {
                return game.move({ from: m.from, to: m.to, promotion: m.promotion || 'q' });
            }

            // Advanced move selection with fallback strategies
            function makeComputerMove() {
                if (game.game_over()) { handleGameOver(); return; }
                if (game.turn() === playerColor) { return; }
                
                updateStatus('Chess Master is thinking...');
                
                setTimeout(() => {
                    // Get all legal moves
                    const legalMoves = game.moves({ verbose: true });
                    if (legalMoves.length === 0) {
                        handleGameOver();
                        return;
                    }
                    
                    // Allocate thinking time based on position complexity
                    const thinkMs = computeAllocatedTimeMs();
                    
                    // Find best move with our advanced engine
                    let best = findBestMoveIterative(thinkMs);
                    
                    // Fallback strategy if no move was found
                    if (!best) {
                        console.log("Primary search failed, using fallback strategy");
                        
                        // First try: pick a move that gives check
                        const checkingMoves = legalMoves.filter(m => {
                            game.move(m);
                            const givesCheck = game.in_check();
                            game.undo();
                            return givesCheck;
                        });
                        
                        if (checkingMoves.length > 0) {
                            best = checkingMoves[Math.floor(Math.random() * checkingMoves.length)];
                        } else {
                            // Second try: pick a capturing move
                            const capturingMoves = legalMoves.filter(m => m.captured);
                            if (capturingMoves.length > 0) {
                                best = capturingMoves[Math.floor(Math.random() * capturingMoves.length)];
                            } else {
                                // Last resort: pick any legal move
                                best = legalMoves[Math.floor(Math.random() * legalMoves.length)];
                            }
                        }
                    }
                    
                    // Apply the selected move
                    const result = applyMoveSpec(best);
                    
                    // Update the board and status
                    board.position(game.fen());
                    updateHighlights();
                    
                    // Display appropriate message based on move type
                    if (result.san.includes('#')) {
                        updateStatus(`Chess Master plays: ${result.san} - Checkmate!`, true);
                    } else if (result.san.includes('+')) {
                        updateStatus(`Chess Master plays: ${result.san} - Check!`);
                    } else if (result.captured) {
                        updateStatus(`Chess Master plays: ${result.san} - Captures ${result.captured.toUpperCase()}`);
                    } else {
                        updateStatus(`Chess Master plays: ${result.san}`);
                    }
                    
                    // Handle game continuation
                    if (!game.game_over()) {
                        if (game.turn() === playerColor) {
                            updateStatus('Your turn.');
                        } else {
                            setTimeout(makeComputerMove, 400);
                        }
                    } else {
                        handleGameOver();
                    }
                }, 10);
            }

            /**
             * Handles the end of the game, displaying the result and animations.
             */
            function handleGameOver() {
                if (game.in_checkmate()) {
                    const loserColor = game.turn();
                    const winnerColor = loserColor === 'w' ? 'b' : 'w';
                    const loserKingSquare = findKing(loserColor);
                    const winnerKingSquare = findKing(winnerColor);

                    $('#myBoard .square-' + loserKingSquare).addClass('highlight-checkmate-loser');
                    $('#myBoard .square-' + winnerKingSquare).addClass('highlight-checkmate-winner');
                    
                    const loserKingPiece = $('#myBoard .square-' + loserKingSquare).find('img');
                    loserKingPiece.addClass('king-capture-animation');

                    updateStatus(`Game Over! Checkmate. ${winnerColor === 'w' ? 'White' : 'Black'} wins!`, true);

                } else if (game.in_stalemate()) {
                    updateStatus("Game Over! Stalemate. It's a draw.", false);
                } else if (game.in_draw()) {
                    updateStatus("Game Over! Draw.", false);
                } else if (game.in_threefold_repetition()) {
                    updateStatus("Game Over! Draw by threefold repetition.", false);
                } else if (game.insufficient_material()) {
                    updateStatus("Game Over! Draw by insufficient material.", false);
                }
                twoPlayerModeActive = false;
                $startTwoPlayerBtn.hide();
                $evaluationDisplay.empty(); 
                console.log('Game Over. All states cleared.');
            }

            /**
             * Updates the status message and board highlight.
             * @param {string} text - The message to display.
             * @param {boolean} isCorrect - Whether the move was correct or not.
             */
            function updateStatus(text, isCorrect) {
                $statusMove.html(text);
                $boardElement.removeClass('highlight-correct highlight-incorrect');
                if (isCorrect === true) { $boardElement.addClass('highlight-correct'); }
                else if (isCorrect === false) { $boardElement.addClass('highlight-incorrect'); }
                
                if (text.includes("Opening complete") || text.includes("Game Over") || text.includes("Computer is thinking") || text.includes("Analyzing...")) {
                    // Do not remove highlight
                } else {
                    if (thinkingProcess) clearTimeout(thinkingProcess);
                    thinkingProcess = setTimeout(() => $boardElement.removeClass('highlight-correct highlight-incorrect'), 1200);
                }
            }

            /**
             * Starts the opening practice.
             */
            function startPractice() {
                clearArrow();
                clearHighlights();
                console.log('Starting new practice...');
                game = new Chess();
                currentMoveIndex = 0;
                playerColor = $playerColorSelect.val();
                twoPlayerModeActive = false;
                $startTwoPlayerBtn.hide();
                $evaluationDisplay.empty(); 
                
                const selectedCategory = $categorySelect.val();
                const selectedOpening = $openingSelect.val();
                const selectedVariation = $variationSelect.val();
                if (!selectedCategory || !selectedOpening || !selectedVariation) { alert("Please select a complete opening line."); return; }
                currentOpeningMoves = openingBook[selectedCategory][selectedOpening][selectedVariation];
                
                const boardConfig = {
                    draggable: true, 
                    position: 'start', 
                    onDrop: onDrop,
                    onSquareClick: onSquareClick,
                    orientation: playerColor === 'w' ? 'white' : 'black',
                    pieceTheme: 'chesspieces/wikipedia/{piece}.png'
                };
                $('#myBoard').empty();
                board = Chessboard('myBoard', boardConfig);
                $(window).off('resize').on('resize', board.resize);
                $statusOpening.text(`${selectedOpening}: ${selectedVariation}`);

                displayEvaluation(null, null, null);

                if (playerColor === 'w' && game.turn() === 'w') {
                    updateStatus('Practice started. Your turn (White).');
                } else if (playerColor === 'b' && game.turn() === 'w') {
                    updateStatus('Practice started. Opponent (White) to move first (Book move).');
                    setTimeout(makeComputerMoveInBookMode, 500);
                } else {
                    updateStatus('Practice started. Your turn (White).', true);
                }
            }

            /**
             * Undoes the last move.
             */
            function undoLastMove() {
                clearArrow();
                if (game.history().length === 0) {
                    updateStatus("No moves to undo!", false);
                    return;
                }

                if (currentMoveIndex < currentOpeningMoves.length) {
                    game.undo();
                    if (currentMoveIndex > 0) currentMoveIndex--;
                    updateStatus(`1 move undone.`, true);
                } else {
                    let lastMove = game.history()[game.history().length - 1];
                    game.undo();
                    updateStatus(`1 move undone.`, true);
                }
                
                board.position(game.fen());
                updateHighlights();
                if (currentMoveIndex >= currentOpeningMoves.length) {
                    $statusMove.text(`Player ${game.turn() === 'w' ? 'White' : 'Black'}'s turn.`);
                }
                displayEvaluation(null, null, null);
            }

            $undoBtn.on('click', undoLastMove);

            $startBtn.on('click', startPractice);
            $resetBtn.on('click', () => {
                clearArrow();
                clearHighlights();
                board.start();
                game.reset();
                currentMoveIndex = 0; 
                twoPlayerModeActive = false;
                $startTwoPlayerBtn.hide();
                $statusOpening.text("Board Reset");
                $statusMove.text("Select an opening and start.");
                $evaluationDisplay.empty();
                console.log('Board reset. All states cleared.');
            });

                        // Two-Player Mode button is now hidden and unused since we continue with computer
            // $startTwoPlayerBtn.on('click', () => { ... });

            $(window).resize(() => {
                // No-op
            });

            // Keyboard shortcuts
            $(document).keydown(function(e) {
                if (e.key === 'Escape') {
                    clearHighlights();
                    clearArrow();
                    squareSelected = null;
                    legalMovesForSelectedPiece = [];
                    updateStatus('Selection cleared. Click on a piece to select it.');
                }
            });

            // Enhanced touch and click support for mobile and desktop
            $(document).on('click touchstart', '#myBoard .square-55d63', function(e) {
                e.preventDefault();
                const square = $(this).attr('class').match(/square-([a-h][1-8])/)?.[1];
                if (square) {
                    onSquareClick(square);
                }
            });

            // Mobile-specific improvements
            if ('ontouchstart' in window) {
                // Touch device optimizations
                $('.btn').css('min-height', '56px');
                $('.form-select').css('min-height', '52px');
                
                // Prevent zoom on double tap for buttons
                $('.btn').on('touchend', function(e) {
                    e.preventDefault();
                    $(this).trigger('click');
                });

                // Better touch handling for chess board
                $('#myBoard').on('touchstart', function(e) {
                    if (e.touches.length > 1) {
                        e.preventDefault(); // Prevent pinch zoom
                    }
                });

                // Add haptic feedback for mobile (if supported)
                if (navigator.vibrate) {
                    $('.btn').on('click', function() {
                        navigator.vibrate(50);
                    });
                }

                // Prevent text selection on mobile
                $('body').css('-webkit-touch-callout', 'none');
                $('body').css('-webkit-user-select', 'none');
                $('body').css('-khtml-user-select', 'none');
                $('body').css('-moz-user-select', 'none');
                $('body').css('-ms-user-select', 'none');
                $('body').css('user-select', 'none');
            }

            // Responsive board sizing
            function resizeBoard() {
                const container = $('.board-container');
                const containerWidth = container.width();
                const maxBoardSize = Math.min(containerWidth - 32, 500); // 32px for padding
                
                if (board && board.resize) {
                    board.resize();
                }
            }

            // Handle window resize
            $(window).on('resize', resizeBoard);
            resizeBoard();

            // Prevent zoom on mobile
            document.addEventListener('gesturestart', function(e) {
                e.preventDefault();
            });

            document.addEventListener('gesturechange', function(e) {
                e.preventDefault();
            });

            document.addEventListener('gestureend', function(e) {
                e.preventDefault();
            });

            // Initial setup
            populateCategories();
            const initialConfig = { 
                draggable: true, 
                position: 'start', 
                onDrop: onDrop,
                onSquareClick: onSquareClick,
                orientation: playerColor === 'w' ? 'white' : 'black',
                pieceTheme: 'chesspieces/wikipedia/{piece}.png'
            };
            board = Chessboard('myBoard', initialConfig); 
            $(window).resize(board.resize);
        });
    </script>

</body>
</html>